using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine.InputSystem;
using UnityEngine;

public class PlayerController : MonoBehaviour
{
    // This is a reference to the PlayerControl script, generated by the InputController
    private PlayerInput playerInput;

    // Stores a reference to the playerInput.actions["Jump"]
    private InputAction jumpAction;
    private InputAction moveAction;
    private InputAction fireAction;

    private Vector2 moveDirection;
    public Vector3 Velocity;
    private Vector3 _lastPosition;

    // Game Logics
    public float moveSpeed {get; private set;}
    private float horizontal;
    private float jumpingPower;
    private bool isFacingRight = true;

    public bool LandingThisFrame;
    public bool JumpingThisFrame;

    // Jump Logic
    private bool startedJumpThisFrame;
    private bool endedJumpThisFrame;
    private float _lastJumpPressed;

    // Walk/Run Logic (Horizontal: Right is positive (1); Left is negative (-1))
    private float horizontalInput;

    #region Collisions
    [Header("COLLISION")]
    [SerializeField] private Bounds _characterBounds;
    [SerializeField] private LayerMask _groundLayer;
    [SerializeField] private int _detectorCount = 3;
    [SerializeField] private float _detectionRayLength = 0.1f;
    [SerializeField] [Range(0.1f, 0.3f)] private float _rayBuffer = 0.1f;

    private float _timeLeftGrounded;

    private RayRange _raysUp, _raysRight, _raysDown, _raysLeft; 
    private bool _colUp, _colRight, _colDown, _colLeft; // are we colliding w/ smth. up/down/right/left

    private struct RayRange {
        public readonly Vector2 Start, End, Dir;
        public RayRange(float x1, float y1, float x2, float y2, Vector2 dir) {
            Start = new Vector2(x1, y1);
            End = new Vector2(x2, y2);
            Dir = dir;
        }
    }

    private void RunCollisionChecks() {
        // Emit ray ranges from the character (up, down, left, right)
        CalculateRayRanges();
        LandingThisFrame = false;

        _colDown = RunEdgeDetection(_raysDown);
        _colUp = RunEdgeDetection(_raysUp);
        _colLeft = RunEdgeDetection(_raysLeft);
        _colRight = RunEdgeDetection(_raysRight);

        // Debug.Log("ColDown " + _colDown);
        // Debug.Log("ColUp " + _colUp);
        // Debug.Log("ColLeft " + _colLeft);
        // Debug.Log("ColRight " + _colRight);
    }

    private bool RunEdgeDetection(RayRange range) {
        return EvaluateRayPositions(range).Any(point => Physics2D.Raycast(point, range.Dir, _detectionRayLength, _groundLayer));
    }

    // This function takes in an edge (RayRange), and produces a list of evenly split points along that edge (# of points = detectorCount)
    private IEnumerable<Vector2> EvaluateRayPositions(RayRange range) {
        for (var i = 0; i < _detectorCount; i++) {
            var alpha = (float) i / (_detectorCount - 1);  // 0, 1/2, 2/2
            yield return Vector2.Lerp(range.Start, range.End, alpha);
        }
    }

    // Helper function that provides the rays that act as edges for the bounding box.
    private void CalculateRayRanges() {
        var b = new Bounds(transform.position + _characterBounds.center, _characterBounds.size);
        _raysDown = new RayRange(b.min.x + _rayBuffer, b.min.y, b.max.x - _rayBuffer, b.min.y, Vector2.down); // bottom edge
        _raysUp = new RayRange(b.min.x + _rayBuffer, b.max.y, b.max.x - _rayBuffer, b.max.y, Vector2.up); // top edge 
        _raysLeft = new RayRange(b.min.x, b.min.y + _rayBuffer, b.min.x, b.max.y - _rayBuffer, Vector2.left); // left edge 
        _raysRight = new RayRange(b.max.x, b.min.y + _rayBuffer, b.max.x, b.max.y - _rayBuffer, Vector2.right); // right edge
    }

    #endregion 

    private void Awake() {
        playerInput = GetComponent<PlayerInput>();
        // We can subscribe the playerInput to actions manually, or we can 
        // create holders in the variable, jumpAction
        jumpAction = playerInput.actions["Jump"];
        moveAction = playerInput.actions["Move"];
        fireAction = playerInput.actions["Fire"];
    }

    private void GatherInput() {
        startedJumpThisFrame = jumpAction.WasPressedThisFrame(); //jumpdown
        endedJumpThisFrame = jumpAction.WasReleasedThisFrame(); //jumpup
        horizontalInput = moveAction.ReadValue<float>(); //horizontalInput

        if (startedJumpThisFrame) {
            _lastJumpPressed = Time.time;
        }
    }

    #region Move

    [Header("MOVE")]
    [SerializeField] private int _freeColliderIterations = 10;
    Vector3 RawMovement;

    private void MoveCharacter() {
        var pos = transform.position + _characterBounds.center;
        RawMovement = new Vector3(_currentHorizontalSpeed, _currentVerticalSpeed);
        var move = RawMovement * Time.deltaTime;
        var furtherPoint = pos + move;

        // if we are not near the ground, just move the character to the furthest point possible
        var hit = Physics2D.OverlapBox(furtherPoint, _characterBounds.size, 0, _groundLayer);
        if (!hit) {
            transform.position += move;
            return;
        }
        else {
            var positionToMoveTo = transform.position;
            for (int i = 1; i < _freeColliderIterations; i++) {
                var alpha = (float) i / _freeColliderIterations;
                var posToTry = Vector2.Lerp(pos, furtherPoint, alpha);

                if (Physics2D.OverlapBox(posToTry, _characterBounds.size, 0, _groundLayer)) {
                    transform.position = positionToMoveTo;

                    if (i == 1) {
                        if (_currentVerticalSpeed < 0) _currentVerticalSpeed = 0;
                        var dir = transform.position - hit.transform.position;
                        transform.position += dir.normalized * move.magnitude;
                    }

                    return;
                }

                positionToMoveTo = posToTry;
            }
        }
    }

    #endregion

    #region Walk
    [Header("WALKING")]
    [SerializeField] private float _acceleration = 90;
    [SerializeField] private float _moveClamp = 13;
    [SerializeField] private float _deAcceleration = 60f;
    [SerializeField] private float _apexBonus = 2;

    private float _currentHorizontalSpeed, _currentVerticalSpeed;

    private void CalculateWalk() {
        if (horizontalInput != 0) {
            // Set horizontal move speed
            _currentHorizontalSpeed += horizontalInput * _acceleration * Time.deltaTime;

            // Clamp the horizontal speed by the fastest a character can travel in one frame (_moveClamp)
            _currentHorizontalSpeed = Mathf.Clamp(_currentHorizontalSpeed, -_moveClamp, _moveClamp);

            var apexBonus = Mathf.Sign(horizontalInput) * _apexBonus * _apexPoint;
            _currentHorizontalSpeed += apexBonus * Time.deltaTime;
        }
        // No input, let's slow the character down...
        else {
            _currentHorizontalSpeed = Mathf.MoveTowards(_currentHorizontalSpeed, 0, _deAcceleration * Time.deltaTime);
        }

        // Add collision detection so we don't run through walls...
        if (_currentHorizontalSpeed > 0 && _colRight || _currentHorizontalSpeed < 0 && _colLeft) {
            _currentHorizontalSpeed = 0;
        }
    }

    #endregion

    #region Gravity
    [Header("Gravity")]
    [SerializeField] private float _fallClamp = -40f;
    [SerializeField] private float _minFallSpeed = 80f;
    [SerializeField] private float _maxFallSpeed = 120f;
    private float _fallSpeed;

    private void CalculateGravity() {
        if (_colDown) {
            if (_currentVerticalSpeed < 0) _currentVerticalSpeed = 0;
        }
        else {
            var fallSpeed = _endedJumpEarly && _currentVerticalSpeed > 0 ? _fallSpeed * _jumpEndEarlyGravityModifier : _fallSpeed;

            _currentVerticalSpeed -= fallSpeed * Time.deltaTime;

            if (_currentVerticalSpeed < _fallClamp) _currentVerticalSpeed = _fallClamp;
        }
    }


    #endregion

    #region Jump
    [Header("JUMPING")] [SerializeField] private float _jumpHeight = 30;
    [SerializeField] private float _jumpApexThreshold = 10f;
    [SerializeField] private float _coyoteTimeThreshold = 0.1f;
    [SerializeField] private float _jumpBuffer = 0.1f;
    [SerializeField] private float _jumpEndEarlyGravityModifier = 3;
    private bool _coyoteUsable;
    private bool _endedJumpEarly = true;
    private float _apexPoint; // Becomes 1 at the apex of a jump
    private bool CanUseCoyote => _coyoteUsable && !_colDown && _timeLeftGrounded + _coyoteTimeThreshold > Time.time;
    private bool HasBufferedJump => _colDown && _lastJumpPressed + _jumpBuffer > Time.time;

    private void CalculateJumpApex() {
        if (!_colDown) {
            _apexPoint = Mathf.InverseLerp(_jumpApexThreshold, 0, Mathf.Abs(Velocity.y)); // this function provides the alpha value that a point occupies between A and B
            _fallSpeed = Mathf.Lerp(_minFallSpeed, _maxFallSpeed, _apexPoint); // in the beginning, as we jump our fallspeed is low, as we reach the apex, our fallspeed increases to max
        } else {
            _apexPoint = 0;
        }
    }

    private void CalculateJump() {
        if (startedJumpThisFrame && CanUseCoyote || HasBufferedJump) {
            _currentVerticalSpeed = _jumpHeight;
            _endedJumpEarly = false;
            _coyoteUsable = false;
            _timeLeftGrounded = float.MinValue;
            JumpingThisFrame = true;    
        }
        else {
            JumpingThisFrame = false;
        }

        if (!_colDown && endedJumpThisFrame && !_endedJumpEarly && Velocity.y > 0) {
            // _currentVerticalSpeed = 0;
            _endedJumpEarly = true;
        }

        if (_colUp) {
            if (_currentVerticalSpeed > 0) _currentVerticalSpeed = 0;
        }
    }

    #endregion

    private void Start() {
    }

    // // This is called when the PlayerController component is enabled.
    // private void OnEnable() {
    //     jumpAction.enabled = true;
    //     moveAction.enabled = true;
    //     fireAction.enabled = true;
    // }

    // // This is called when the PlayerController component is disabled.
    // private void OnDisable() {
    //     jumpAction.enabled = false;
    //     moveAction.enabled = false;
    //     fireAction.enabled = false;
    // }

    // Update is called once per frame
    void Update()
    {
        Velocity = (transform.position - _lastPosition) / Time.deltaTime;
        _lastPosition = transform.position;

        GatherInput();
        RunCollisionChecks();

        CalculateWalk(); // Horizontal movement
        CalculateJumpApex(); // Affects fall speed, so calculate before gravity
        CalculateGravity(); // Vertical movement
        CalculateJump(); // Possibly overrides vertical

        MoveCharacter();
    }

    // Does not need to be called, just runs in the editor
    void OnDrawGizmos() {
        Gizmos.color = Color.yellow;
        Gizmos.DrawWireCube(transform.position + _characterBounds.center, _characterBounds.size);
        
        Gizmos.color = Color.red;
        var b = new Bounds(transform.position + _characterBounds.center, _characterBounds.size);
        // _raysDown = new RayRange(b.min.x + _rayBuffer, b.min.y, b.max.x - _rayBuffer, b.max.y, Vector2.down);
        Gizmos.DrawSphere(new Vector2(b.min.x + _rayBuffer, b.min.y), 1);
        Gizmos.color = Color.blue;
        Gizmos.DrawSphere(new Vector2(b.max.x - _rayBuffer, b.max.y), 1);
    }

    void FixedUpdate()
    {
    }

    public void Move(InputAction.CallbackContext context) {
        Debug.Log("Moving");
    }

    public void Fire(InputAction.CallbackContext context) {
        Debug.Log("Firing");
    }

    public void Jump(InputAction.CallbackContext context) {
        Debug.Log("Jumping");
    }
}
